---
title: 대상 유효성 검사
description: Experience Platform이 대상자가 다운스트림에서 더 나은 성능을 발휘하는지 확인하기 위해 대상자를 확인하는 방법을 알아봅니다.
source-git-commit: 52439e55d3c48631488b17b6b04256bcbbe37bcb
workflow-type: tm+mt
source-wordcount: '1630'
ht-degree: 1%

---


# 대상 유효성 검사

Adobe Experience Platform에서 대상 정의를 작성할 때 대상 유효성 검사는 내장된 유효성 검사 및 가드레일을 제공하여 대상이 정확할 뿐만 아니라 안정적이고 확장 가능한지 확인합니다.

대상 정의 모범 사례를 준수하여 대상을 보다 빠르게 평가할 수 있고, 대상 크기가 커져도 논리를 효율적으로 유지할 수 있으며, 트래픽이 많은 기간 동안 평가 실패의 위험을 줄일 수 있습니다. 또한 최적화된 대상은 대상에 대한 활성화 속도를 개선하고, 실시간 개인화 지연 시간을 줄이며, 전반적인 샌드박스 안정성을 유지합니다.

Experience Platform은 세그먼트 빌더에서 대상을 구축할 때 이러한 유효성 검사를 실시간으로 실행합니다. 유효성 검사 임계값을 초과하는 이벤트 또는 속성을 추가하면 세그먼트 빌더 인터페이스 내에서 즉시 피드백을 받게 됩니다.

## 유효성 검사 유형 {#validation-types}

대상에서 대상 유효성 검사가 실행되면 위반할 수 있는 구문은 크게 유효성 검사 구문과 성능 최적화 구문이라는 두 가지 유형이 있습니다.

중요한 유효성 검사 구문이 위반되면 시스템은 샌드박스의 안정성을 보호하기 위해 대상을 저장하지 못하게 합니다. 성능 최적화 구문이 위반되면 대상을 저장할 수 있지만 성능 문제를 방지하기 위해 대상 정의를 업데이트하는 것은 *적극 권장*&#x200B;입니다.

## 유효성 검사 {#validation-checks}

현재 다음 유효성 검사가 지원됩니다.

| 유효성 검사 | 유형 | 임계값 |
| ---------------- | ---- | --------- |
| 논리적 복잡성 | 중요 유효성 검사 | 대상 정의에 너무 많은 쿼리가 포함되어 있어 불필요한 논리적 복잡성이 발생합니다. |
| 순차적 이벤트 | 중요 유효성 검사 | 대상 정의 내에 6개 이상의 순차적 이벤트가 있습니다. |
| 집계된 수 | 성능 최적화 | 대상 정의 내에 3개 이상의 집계 함수가 있습니다. |
| 중첩된 데이터 | 성능 최적화 | 대상 정의 내에는 2개 이상의 중첩된 데이터(배열 또는 맵 데이터 유형) 깊이가 있습니다. |
| 대상자 크기 | 성능 최적화 | 대상 자격 크기는 샌드박스의 총 프로필 수의 30%보다 큽니다. |

### [!BADGE 중요한 유효성 검사]{type=Negative} 논리적 복잡성 {#logical-complexity}

>[!CONTEXTUALHELP]
>id="platform_segmentation_segmentbuilder_rewritescheck"
>title="쿼리 효율성 경고"
>abstract="대상에 쿼리가 너무 많아 논리적인 문제가 불필요하게 됩니다. 계속하기 전에 대상 정의를 단순화하십시오."

>[!CONTEXTUALHELP]
>id="platform_segmentation_segmentbuilder_cnfcomplexitycheck"
>title="로직 복잡성"
>abstract="대상에 쿼리가 너무 많아 논리적인 문제가 불필요하게 됩니다. 계속하기 전에 대상 정의를 단순화하십시오."

논리적 복잡성 유효성 검사는 대상 정의 내에서 논리적 문(AND, OR, NOT)의 구조를 분석합니다. 특히, 시스템에서 프로필당 과도한 수의 비교를 수행하도록 하는 대상 정의를 찾습니다.

대상 정의에 프로필당 비교 횟수가 과도하게 많으면 이러한 복잡성 증가로 인해 프로필별 평가 속도가 느려집니다. 그 결과, 대상자 평가에 소요되는 전체 시간이 늘어납니다.

이 유효성 검사가 트리거되지 않도록 하려면 대상 정의를 간단하게 유지합니다. 자체 대상 정의를 이해할 수 없는 경우에는 너무 복잡하고 Experience Platform에서 대상을 평가하는 데 시간이 더 걸릴 수 있습니다.

**예**

특정 주에 거주하는 고객을 찾고 싶다고 가정해 보겠습니다. _can_&#x200B;은(는) 프로필에 나열된 45개 값 중 하나와 일치하는 상태에 대한 값이 있는지 확인하여 다음과 같이 비효율적으로 쓸 수 있습니다.

+++ 비효율적인 대상 정의

```
State.equals("AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA","HI", "ID", "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY", "NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT")
```

+++

그러나 not 체크를 사용하면 프로필에 5개의 나열된 값 중 하나가 없는지 확인하기만 하면 되므로 훨씬 효율적인 쿼리를 만들 수 있습니다.

+++ 효율적인 대상 정의

```
not(State.equals("VT", "VA", "WA", "WV", "WI", "WY" ))
```

+++

또는 체험판 플랜에서 캐나다인인 고객을 찾고 싶다고 가정해 보겠습니다. 덜 효율적인 접근 방법은 수동으로 다른 모든 계획을 하나씩 제외하고 프로필이 다른 계획에 없는지 확인하여 자신의 시험 플랜에 캐나다인을 찾는 것입니다.

+++ 비효율적인 대상 정의

```
NOT(
    plan.equals("basic") OR
    plan.equals("standard") OR
    plan.equals("premium") OR
    plan.equals("enterprise")
) AND NOT (
    region.equals("us-east") OR
    region.equals("us-west") OR
    region.equals("eu-central") OR
    region.equals("apac")
)
```

+++

대신, 포함하려는 특정 플랜을 직접 타겟팅해야 합니다.

+++ 효율적인 대상 정의

```
plan.equals("trial") AND region.equals("canada")
```

+++

### [!BADGE 중요 유효성 검사]{type=Negative} 순차적 이벤트 복잡성 {#sequential-event-complexity}

>[!CONTEXTUALHELP]
>id="platform_segmentation_segmentbuilder_chaincountcheck"
>title="이벤트 시퀀스 제한"
>abstract="대상에 너무 많은 순차적 이벤트가 포함되어 있습니다. 대상 정의 내에 최대 6개의 순차적 이벤트만 가질 수 있습니다. 계속하기 전에 대상 정의에서 일부 순차적 이벤트를 제거하십시오."

순차적 이벤트 복잡도 유효성 검사는 시퀀스에서 순차적 이벤트의 수를 6개 이벤트로 제한합니다.

시스템은 고객의 전체 Experience 이벤트 내역을 스캔하고, 타임스탬프별로 정렬하며, 지정된 순서가 쿼리와 일치하는지 확인해야 하므로 순차적 세그먼테이션은 Experience Platform 내에서 계산적으로 가장 복잡한 작업 중 하나입니다. 그 결과 연쇄가 커지면 계가 계산해야 하는 순열의 수는 급격히 증가한다.

이 유효성 검사가 트리거되지 않도록 여정의 시작, 중간 및 끝을 정의하여 순차적 체인의 기본 사항에 중점을 둡니다. 즉각적인 단계는 종종 최종 변환 내에 암시됩니다.

**예**

제품을 보고 장바구니에 추가한 사용자를 타겟팅한다고 가정해 보겠습니다. 덜 효율적인 접근법은 사용자의 경로의 모든 개별 상태를 점검할 것이다. 예를 들어 다음 쿼리는 다음과 같은 일련의 이벤트를 거칩니다. 웹 사이트에 로그인 -> 제품 검색 -> 제품 페이지 보기 -> 장바구니에 추가 -> 체크아웃으로 이동 -> 구매 이벤트

+++ 비효율적인 대상 정의

```
chain(xEvent, timestamp, [ A: WHAT(eventType = "login"), B: WHAT(eventType = "search"), C: WHAT(eventType = "productView"), D: WHAT(eventType = "addToCart"), E: WHAT(eventType = "checkout"), F: WHAT(eventType = "purchase") ])
```

+++

그러나 시퀀스를 시작, 중간 및 끝으로 줄이면 3개의 이벤트 길이인 이벤트 시퀀스만 있으면 보다 효율적인 쿼리가 생성됩니다. 예를 들어 다음 쿼리는 다음과 같은 일련의 이벤트를 거칩니다. 제품 페이지 보기 -> 장바구니에 추가 -> 구매 이벤트

+++ 효율적인 대상 정의

```
chain(xEvent, timestamp, [ A: WHAT(eventType = "productView"), B: WHAT(eventType = "addToCart"), C: WHAT(eventType = "purchase") ])
```

+++

### [!BADGE 성능 최적화]{type=Caution} 집계된 개수 {#aggregated-count}

>[!CONTEXTUALHELP]
>id="platform_segmentation_segmentbuilder_countaggregationcheck"
>title="카운트 필터 경고"
>abstract="대상에 집계 이벤트가 너무 많습니다. 대상자 내에서 최대 3개의 집계 이벤트를 사용해야 합니다. 성능 문제를 방지하려면 대상 정의에서 일부 집계 이벤트를 제거해야 합니다."

집계된 카운트 검사는 대상자 내에서 사용되는 집계 이벤트 수를 3개의 조건으로 제한합니다.

표준 이벤트는 사용자를 자격을 부여하기 위해 일치하는 단일 이벤트만 찾으면 됩니다. 그러나 집계 이벤트는 결정을 내리기 전에 사용자의 **전체 내역**&#x200B;을 읽고 분석해야 하므로 더 많은 집계 이벤트를 사용하여 처리 시간이 느려집니다.

이 유효성 검사가 트리거되지 않도록 하려면 대상 정의에 반드시 필요한 경우에만 특정 수를 사용하십시오. 예를 들어 사용자가 한 번 참여했는지 여부만 알고 있으면 &quot;카운트 > 0&quot; 이벤트를 사용하지 않고 표준 &quot;존재함&quot; 논리를 사용할 수 있습니다.

### [!BADGE 성능 최적화]{type=Caution} 중첩된 데이터 복잡성 {#nested-data-complexity}

>[!CONTEXTUALHELP]
>id="platform_segmentation_segmentbuilder_arraydepthcheck"
>title="중첩 데이터 경고"
>abstract="대상에 중첩된 데이터 레이어가 너무 많습니다. 대상자 내에서 최대 2개의 데이터 레이어를 사용해야 합니다. 성능 문제를 방지하려면 대상 정의를 평면화해야 합니다."

중첩된 데이터 복잡성 유효성 검사는 대상 정의 내의 중첩된 데이터 수를 2개의 레이어로 제한합니다.

Experience Platform에서는 배열 및 맵 개체를 사용하여 복잡한 데이터 유형을 저장할 수 있지만, 중첩된 구조의 압축을 풀고 값을 찾으려면 더 복잡한 순회 논리가 필요합니다. 데이터가 더 깊이 배열에 중첩되어 있을수록 유효성 검사를 위해 검색하는 데 더 오래 걸립니다.

깊게 중첩된 속성에 대해 세분화를 자주 수행하는 경우 보다 쉽게 액세스할 수 있도록 데이터 엔지니어링 팀에 문의하여 속성을 프로필 스키마 내의 상위 수준으로 복사해야 할 수 있습니다.

### [!BADGE 성능 최적화]{type=Caution} 대상 크기 {#audience-size}

>[!CONTEXTUALHELP]
>id="platform_segmentation_segmentbuilder_profilestorecheck"
>title="대상 크기 경고"
>abstract="대상이 너무 광범위하게 작성되었습니다. 샌드박스에 총 프로필의 30% 이상을 사용할 수 있는 대상 정의를 작성하지 마십시오. 성능 문제를 방지하려면 대상 정의를 강화해야 합니다."

대상 크기 유효성 검사는 대상 정의가 샌드박스에 있는 총 프로필의 30% 이상이 대상에 적합한지 확인합니다.

Experience Platform은 큰 대상을 처리할 수 있지만 너무 모호한 대상 정의(예: 모든 활성 고객)는 평가 시간 및 활성화 지연을 증가시킬 수 있습니다.

프로필 스토어의 30% 이상을 충족하는 대상을 만들어야 하는 경우 유연한 대상 평가를 사용하여 대상의 첫 번째 평가가 수행되도록 하십시오. 온디맨드 평가로 대상자를 평가하면 대규모 대상자가 일별 세분화 작업에 미치는 전반적인 영향을 줄일 수 있습니다.

## 다음 단계

이 안내서를 읽고 나면 Experience Platform에서 자동 유효성 검사를 실행하여 평가, 안정성 및 확장성을 개선하는 방법을 더 잘 이해할 수 있습니다. UI를 사용하여 대상을 만드는 방법에 대한 자세한 내용은 [세그먼트 빌더 설명서](./ui/segment-builder.md)를 참조하세요.

## 부록

다음 부록에는 Experience Platform의 대상 유효성 검사에 대한 faq가 나열되어 있습니다.

### 자주 묻는 질문 {#faq}

**경고를 무시하고 대상자를 저장하면 어떻게 됩니까?**

+++ 답변

성능 최적화 경고의 경우 대상이 저장되고 시스템은 평가를 시도합니다. 그러나 처리 시간이 크게 느려질 수 있습니다. 극단적인 상황에서는 데이터 볼륨이 충분히 높으면 세분화 작업이 실패하거나 시간 초과되어 대상을 다시 설계해야 할 수 있습니다.

심각한 유효성 검사 오류의 경우 대상자를 저장할 수 없습니다.

+++

**&quot;순차적 이벤트&quot; 제한에 대한 증가를 요청할 수 있습니까?**

+++ 답변

아니요, 할 수 없습니다. 전체 Experience Platform 환경의 안정성을 보호하기 위해 설계된 하드 가드레일입니다. 시퀀스에 6단계 이상이 필요한 경우 논리를 단순화하거나 두 개의 다른 대상(예: &quot;참여&quot; 대상 및 &quot;전환&quot; 대상)으로 세분화해야 한다는 강력한 표시기입니다.

+++

**이 새 유효성 검사가 기존 대상자를 손상시킬 수 있습니까?**

+++ 답변

이러한 유효성 검사는 **작성**&#x200B;할 때 실행됩니다. 따라서 기존 대상자는 그대로 계속 실행됩니다. 그러나 이러한 규칙을 위반하는 기존 대상자를 편집하려고 하면 변경 사항을 저장하기 전에 먼저 최적화해야 합니다.

+++

**복잡한 데이터 요구 사항이 있습니다. &quot;중첩된 데이터&quot; 경고를 방지하려면 어떻게 해야 합니까?**

+++ 답변

데이터 모델링 레이어에서 &quot;중첩된 데이터&quot; 경고를 피하는 것이 가장 좋습니다. 일부 팁에는 데이터 엔지니어링 팀과 협력하여 XDM 스키마를 병합하고 중요한 속성(예: `subscriptionStatus` 및 `loyaltyTier`)을 프로필의 최상위 수준으로 가져오는 작업이 포함됩니다.

+++

**이러한 검사가 초안 대상자와 게시된 대상자 모두에 적용됩니까?**

+++ 답변

예. 이러한 검사는 Experience Platform에서 평가된 *모두*&#x200B;개 대상에 적용됩니다.

+++
